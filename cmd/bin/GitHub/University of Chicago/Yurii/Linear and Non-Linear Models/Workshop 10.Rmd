---
title: "Lecture 10"
author: "Adham Suliman"
date: "August 25, 2018"
output: html_document
---

```{r setup, include=FALSE}
#rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
if(!"pacman" %in% rownames(installed.packages())) {
  install.packages("pacman")
}
pacman::p_load(tidyverse,faraway,corrplot, tinytex, dplyr,zoo, knitr, rgl, relaimpo, MuMIn, broom,ggplot2, tidyr, fields, cluster, data.table, reshape2,poLCA, stats, AER, MASS, pscl, faraway, pscl, lattice, latticeExtra, copula,rmvdc, animation,knitr,depmixS4,rWind)
```


Markov Probabilities

No memories of previous events.
Each row represetnts a sate and must sum to 0.(stochiastic matrix)
All transitions are independent of one another. 

Transition matrix is created by dot product of step matrices. This tells you the probability of starting at oen state and ending at one with a certain number of steps.

To tell which sate you are actually in is a bit more difficult. 

Linear regression is created for switch in states which equates to Coefficients of beta is different for different states

First unhide the states, then find the conditional probabilities of transition.

When you are unhiding, it has to be unsupervised data. 

Self organizing maps: 
Neuros(outsiders) are presented in a sample(featuers). Neurons move in iterations towards features.Neuroons move master to a given feature dependent on how close they are. (Kmeans. )

```{r cars}
library(animation)
lambda=5
oopt = ani.options(interval = .5, nmax = 25) ## set some options first
MC.Matrix<-rbind(
From.Pos1=c(To.Pos1=1,To.Pos2=0,To.Pos3=0,To.Pos4=0),
                 From.Pos2=c(To.Pos1=.0,To.Pos2=0.9,To.Pos3=0,To.Pos4=0.1),
                 From.Pos3=c(To.Pos1=0,To.Pos2=.0,To.Pos3=0.9,To.Pos4=.0),
                 From.Pos4=c(To.Pos1=0.9,To.Pos2=0,To.Pos3=0.1,To.Pos4=1))
Current.State<-2
From.To<-rep(Current.State,2)

my.Data<-as.matrix(t(c(0,2)))   ## use loop to create images one by one
for (i in 1:ani.options("nmax")) {
  From.To[1]<-Current.State
  From.To[2]<-sample(1:4,1,prob=MC.Matrix[From.To[1],])
  Current.State<-From.To[2]
  
  wait.next<-rexp(1,lambda)
  my.Data<-rbind(my.Data,c(my.Data[length(my.Data[,1]),1]+1,From.To[2]))
  plot(my.Data,type="s",xlim=c(1,25),ylim=c(0,4),xlab="Time",ylab="State",lwd=3)
  abline(h=1,col="red")
  abline(h=4,col="red")
  ani.pause(wait.next)    ## pause for a while ('interval')
  
}

ani.options(oopt) 
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
MC.Matrix<-data.frame(rbind(From.Pos1=c(To.Pos1=1,To.Pos2=0,To.Pos3=0,To.Pos4=0),
                 From.Pos2=c(To.Pos1=.03,To.Pos2=0,To.Pos3=.97,To.Pos4=0),
                 From.Pos3=c(To.Pos1=0,To.Pos2=.97,To.Pos3=0,To.Pos4=.03),
                 From.Pos4=c(To.Pos1=0,To.Pos2=0,To.Pos3=0,To.Pos4=1)))
kable(MC.Matrix)
```



```{r}
install.packages("depmix")
library('depmix')
data(speed)
sp1 <- data.frame(speed[1:168,])
install.packages("installr"); library(installr)
updateR()
```


```{r}
?depmix
depmix(list(ACC~Pacc,RT~Pacc), nstates=1,data=sp1,family=list(multinomial(),gaussian()))
```



codes plot are states in time. 
```{r}
data <-read.csv('RegressionAssignmentData2014.csv') 
head(data)
```


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
