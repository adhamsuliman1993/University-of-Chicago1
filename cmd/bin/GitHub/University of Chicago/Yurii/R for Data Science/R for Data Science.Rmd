---
title: "R for Data Science"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
if(!"pacman" %in% rownames(installed.packages())) {
  install.packages("pacman")
}
pacman::p_load(tidyverse,faraway,corrplot, tinytex, zoo, knitr, rgl, relaimpo, MuMIn, nycflights13,ggplot2, mass, dplyr)
remove.packages(mass)
```

## R Markdown
tidyverse logic
• Pick observations by their values (filter()).
• Reorder the rows (arrange()).
• Pick variables by their names (select()).
• Create new variables with functions of existing variables
(mutate()).
• Collapse many values down to a single summary (summa
rize()).
• group_by()

1st line looks at filtering
2nd line uses filtering utilizing %in%
```{r cars}
jam1 <- filter(flights, month==1, day==1)
filter(flights, month %in% c(11,12))
```

Find all flights that:
a. Had an arrival delay of two or more hours
b. Flew to Houston (IAH or HOU)
c. Were operated by United, American, or Delta
d. Departed in summer (July, August, and September)
e. Arrived more than two hours late, but didn’t leave late
f. Were delayed by at least an hour, but made up over 30
minutes in flight
g. Departed between midnight and 6 a.m. (inclusive)
2. Another useful dplyr filtering helper is between(). What does it
do? Can you use it to simplify the code needed to answer the
previous challenges?
3. How many flights have a missing dep_time? What other variables
are missing? What might these rows represent?
4. Why is NA ^ 0 not missing? Why is NA | TRUE not missing?
Why is FALSE & NA not missing? Can you figure out the general
rule? (NA * 0 is a tricky counterexample!)

```{r pressure, echo=FALSE}
filter(flights, arr_delay >= 120)
filter(flights, (dest == 'IAH' | dest == 'HOU'))
filter(flights, (carrier == 'UA' | carrier == 'AA' | carrier == 'DL'))
filter(flights, (month == 7 | month==8 | month ==9))
flights %>% filter(between(month, 7, 9))
nrow(filter(flights,is.na(dep_time)))
flights_sml <- flights %>% dplyr::select(year:day, ends_with("delay"), distance, air_time)
```


Mutate is utilized to manipulate fields.
Transmute is used to only return the manipulated columns.
```{r}
mutate(flights_sml, 
       gain = arr_delay - dep_delay,
       speed = distance / air_time * 60,
       hours = air_time / 60,
       gain_per_hour = gain / hours)
```

Known Rank Function
```{r}
y <- c(1, 2, 2, NA, 3, 4)
min_rank(y)
#> [1] 1 2 2 NA 4 5
min_rank(desc(y))
#> [1] 5 3 3 NA 2 1
row_number(y)
#> [1] 1 2 3 NA 4 5
dense_rank(y)
#> [1] 1 2 2 NA 3 4
percent_rank(y)
#> [1] 0.00 0.25 0.25 NA 0.75 1.00
cume_dist(y)
#> [1] 0.2 0.6 0.6 NA 0.8 1.0
```

```{r}
test1<-flights %>% dplyr::select(dep_time, sched_dep_time)
transmute(test1, 
       dep_hour = dep_time %/% 60, 
       dep_min = dep_time%%60, 
       sched_dep_hour = sched_dep_time %/% 60, 
       sched_dep_min = sched_dep_time%%60)
test2<- flights %>% dplyr::select(arr_time,dep_time)
mutate (test2,
        dif = arr_time - dep_time,
        diff_hour = dif %/% 60, 
        diff_minutes = dif %% 60,
        diff_concat = paste('hour: ',diff_hour,' minutes: ',diff_minutes))
```
```{r}
by_dest <- group_by(flights, dest)
delay <- summarize(by_dest,
count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)
)
delay <- filter(delay, count > 20, dest != "HNL")
```

Writing the above utilizing pipe
```{r}
delays <- flights %>%
  group_by(dest) %>%
    summarize(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
    ) %>%
      filter(count > 20, dest != "HNL")
 ggplot(data = delay, mapping = aes(x = dist, y = delay)) +
     geom_point(aes(size = count), alpha = 1/3) +
     geom_smooth(se = FALSE)
```

He we are looking at a positive correlation between skill(ba) and opportunities
to hit the ball (ab)
```{r}
batting <- as_tibble(Batting)
batters <- batting %>%
  group_by(playerID) %>%
  summarize(
    ba = sum(H, na.rm=T) / sum(AB,na.rm = T),
    ab = sum(AB, na.rm=T)
  )

```

The second line of code takes the count with respect to the first object.
```{r}
not_cancelled <- flights %>%
filter(!is.na(dep_delay), !is.na(arr_delay))

not_cancelled %>%
count(tailnum, wt = distance) %>%
  arrange(desc(n))


not_cancelled %>%
  group_by(tailnum) %>%
    summarize(n= sum(distance)) %>%
      arrange(desc(n))
      
```
A flight is 15 minutes early 50% of the time, and 15 minutes
late 50% of the time.
• A flight is always 10 minutes late.
• A flight is 30 minutes early 50% of the time, and 30 minutes
late 50% of the time.
• 99% of the time a flight is on time. 1% of the time it’s 2 hours
late.
Which is more important: arrival delay or departure delay?
```{r}
flight_delay_summary<- flights %>%
                        group_by(flight) %>%
                          summarize(num_flights = n(),
                                    percentage_15_minutes_early = (sum((sched_arr_time - arr_time) > 15))/num_flights,
                                    percentage_15_minutes_late = (sum((dep_delay) > 15))/num_flights)

flight_delay_summary %>%
  filter(percentage_15_minutes_early == .5 & percentage_15_minutes_late == .5)

late_flights<-flights %>%
  group_by(flight) %>%
    summarize(less_than_10 = (mean(arr_delay)<10))

late_flights %>%
  filter(less_than_10 == 1)
```

2. Come up with another approach that will give you the same
output as not_cancelled %>% count(dest) and not_cancel
led %>% count(tailnum, wt = distance) (without using
count()).
3. Our definition of cancelled flights (is.na(dep_delay) |
is.na(arr_delay) ) is slightly suboptimal. Why? Which is the
most important column?
4. Look at the number of cancelled flights per day. Is there a pattern?
Is the proportion of cancelled flights related to the average
delay?
5. Which carrier has the worst delays? Challenge: can you disentangle
the effects of bad airports versus bad carriers? Why/why
not? (Hint: think about flights %>% group_by(carrier,
dest) %>% summarize(n()).)
6. For each plane, count the number of flights before the first delay
of greater than 1 hour.
7. What does the sort argument to count() do? When might you
use it?

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
